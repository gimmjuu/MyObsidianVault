---
tags:
  - CS
---
Hugging Face ü§ó
Python package : Transformers
$ pip install transformers
Pipeline
pipeline Ìï®ÏàòÎäî ÌóàÍπÖÌéòÏù¥Ïä§Ïóê ÏóÖÎ°úÎìúÎêú Î™®Îç∏ÏùÑ Î∂àÎü¨Ïò§Îäî API Í∏∞Îä•ÏùÑ Ï†úÍ≥µÌï®
from transformers import pipeline
Pre-trained Î™®Îç∏ ÏÇ¨Ïö©ÌïòÍ∏∞
ÌóàÍπÖÌéòÏù¥Ïä§ ÌéòÏù¥ÏßÄÏóêÏÑú Ìï¥Îãπ Î™®Îç∏Ïùò TaskÏôÄ Ï£ºÏÜåÎ•º pipeline Ìï®ÏàòÏóê ÏûÖÎ†•ÌïòÎ©¥ Ìï¥Îãπ Î™®Îç∏ÏùÑ Í∞ùÏ≤¥Î°ú Ìò∏Ï∂úÌï®
client = pipeline("{Task}", "{model-address}")
result = client(target-data)
Î™®Îç∏ Î°úÏª¨Ïóê Îã§Ïö¥Î∞õÍ∏∞
ÌóàÍπÖÌéòÏù¥Ïä§ ÌéòÏù¥ÏßÄÏóêÏÑú Ìï¥Îãπ Î™®Îç∏Ïùò File and Versions ÌÉ≠ÏúºÎ°ú Ïù¥Îèô
ÏóÖÎ°úÎìúÎêú ÌååÏùºÏùÑ Ï†ÑÏ≤¥ Îã§Ïö¥Î°úÎìú ÌõÑ,
pipline Ìï®Ïàò Ìò∏Ï∂ú Ïãú Îã§Ïö¥ Î∞õÏùÄ Î°úÏª¨ Í≤ΩÎ°úÎ•º ÏßÄÏ†ïÌï¥Ï§å
client = pipeline(‚Äú{Task}‚Äù, model=‚ÄôC:/path/to/models/target-model‚Äô)

---

##### The Memory Hierarchy
System programming
Î©îÎ™®Î¶¨ ÏãúÏä§ÌÖú Memory System
Ï†ÄÏû• Ïû•ÏπòÎì§Ïùò Í≥ÑÏ∏µÍµ¨Ï°∞

ÏÉÅÏúÑ Í≥ÑÏ∏µÏùºÏàòÎ°ù ÏûëÍ≥†, ÎπÑÏã∏Í≥†, Îπ†Î•∏ Ï†ëÍ∑ºÏù¥ Í∞ÄÎä•Ìï®
Ï¢ãÏùÄ ÏßÄÏó≠ÏÑ±(Locality)Î•º Í∞ñÎäî ÌîÑÎ°úÍ∑∏Îû®ÏùÄ ÎÇòÏÅú ÏßÄÏó≠ÏÑ±ÏùÑ Í∞ÄÏßÑ ÌîÑÎ°úÍ∑∏Îû®Î≥¥Îã§ Ï¢Ä Îçî ÏÉÅÏúÑ Î©îÎ™®Î¶¨ Í≥ÑÏ∏µÏóêÏÑú, Îçî ÎßéÏùÄ Îç∞Ïù¥ÌÑ∞Ïóê Ï†ëÍ∑ºÌïòÎ†§Îäî Í≤ΩÌñ•Ïù¥ ÏûàÏúºÎ©∞, Îçî Îπ®Î¶¨ ÎèåÍ≤å Îê®
LocalityÏóê Îî∞Îùº ÏùëÏö© ÏÑ±Îä•Ïù¥ ÌÅ¨Í≤å Îã¨ÎùºÏßê

ÌúòÎ∞úÏÑ± Î©îÎ™®Î¶¨ Volatile Memory
RAM (Random Access Memory)
Volatile(ÌúòÎ∞úÏÑ±) : ‚ÄúLose information if the supply voltage is turned off.‚Äù
Ï†ÑÏõêÏù¥ Í≥µÍ∏âÎêòÏßÄ ÏïäÏúºÎ©¥ Î©îÎ™®Î¶¨Ïóê Îì§Ïñ¥ÏûàÎçò Ï†ïÎ≥¥Îì§Ïù¥ ÏÜåÎ©∏
Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º RAMÏóê Ï†ÄÏû•ÌïòÎäî Í≤ÉÏùÄ ÎπÑÏö©Í≥º Ï†ÑÎ†• ÏÇ¨Ïö© Î©¥ÏóêÏÑú ÎπÑÌö®Ïú®Ï†Å
RAMÏùò Ï¢ÖÎ•ò
SRAM (Static RAM Ï†ïÏ†ÅÎû®)
ÏßëÏ†ÅÎèÑÍ∞Ä ÎÇÆÍ≥† Ï†ÑÎ†• ÏÜåÎ™®Í∞Ä ÎßéÍ≥† Íµ¨Ï°∞Í∞Ä Î≥µÏû°Ìï¥ÏÑú Ïö©ÎüâÏù¥ ÏûëÏßÄÎßå ÏÜçÎèÑÎäî Îß§Ïö∞ Îπ†Î¶Ñ
CPUÏùò Ï∫êÏãú Î©îÎ™®Î¶¨Î°ú Ï£ºÎ°ú ÏÇ¨Ïö©
Persistent : Ï†ÑÏõê Í≥µÍ∏âÎßå ÏûàÏúºÎ©¥ Î©îÎ™®Î¶¨Í∞Ä Ï†àÎåÄÎ°ú ÏÇ¨ÎùºÏßÄÏßÄ ÏïäÏùå
ÏûêÏô∏ÏÑ†, Ï†ÑÌåå, Ï†ÑÍ∏∞Ïóê Í∞ïÌï®
Lower Density : 1bit Îãπ Ìä∏ÎûúÏßÄÏä§ÌÑ∞ 6Í∞ú ÌïÑÏöî
DRAM (Dynamic RAM ÎèôÏ†ÅÎû®)
ÏßëÏ†ÅÎèÑÍ∞Ä ÎÜíÍ≥† Ï†ÑÎ†•ÏÜåÎ™®Í∞Ä Ï†ÅÍ≥† Íµ¨Ï°∞Í∞Ä Í∞ÑÎã®Ìï¥ÏÑú Ïö©ÎüâÏù¥ ÌÅ∞ Ìé∏
Î©îÏù∏ Î©îÎ™®Î¶¨ÏôÄ Í∑∏ÎûòÌîΩ ÏãúÏä§ÌÖúÏùò ÌîÑÎ†àÏûÑ Î≤ÑÌçºÎ°ú ÏÇ¨Ïö© (ÏùºÎ∞òÏ†ÅÏù∏ PCÏö© Î©îÎ™®Î¶¨)
Need Refresh : Ï†ÑÏõêÏù¥ Í≥µÍ∏âÎêòÏñ¥ ÏûàÏñ¥ÎèÑ Î©îÎ™®Î¶¨Í∞Ä Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú ÏÇ¨ÎùºÏßê
1bit Îãπ Ìä∏ÎûúÏßÄÏä§ÌÑ∞ 1Í∞ú ÌïÑÏöî (SRAMÏóê ÎπÑÌï¥ Ïö©ÎüâÏù¥ 6Î∞∞ Ï†ïÎèÑ ÌÅº)
DRAM Ïπ© ÎÇ¥ ÏÖÄÏùÄ w DRAM ÏÖÄÎ°ú Ïù¥Î£®Ïñ¥ÏßÑ d ÏäàÌçºÏÖÄÎ°ú Íµ¨ÏÑ± ->
d √ó w DRAMÏπ©ÏùÄ d ÏäàÌçºÏÖÄ, ÏäàÌçºÏÖÄÎãπ 8ÎπÑÌä∏Î•º Í∞ÄÏßê

Îç∞Ïù¥ÌÑ∞Îäî ‚ÄòÎ≤ÑÏä§ Bus‚ÄôÎùºÍ≥† ÌïòÎäî Í≥µÏú† Ï†ÑÍ∏∞ÌöåÎ°úÎ•º ÌÜµÌï¥ CPUÏôÄ DRAM Î©îÏù∏ Î©îÎ™®Î¶¨ ÏïûÎí§Î°ú ÍµêÌôòÎê®
Read Transaction : Îç∞Ïù¥ÌÑ∞Î•º Î©îÏù∏Î©îÎ™®Î¶¨ÏóêÏÑú CPUÎ°ú Ïù¥Îèô
Write Transaction : Îç∞Ïù¥ÌÑ∞Î•º CPUÏóêÏÑú Î©îÏù∏Î©îÎ™®Î¶¨Î°ú Ïù¥Îèô

ÎπÑÌúòÎ∞úÏÑ± Î©îÎ™®Î¶¨ Non-volatile Memory
ROM (Read-Only Memory)
Read-Only ÏßÄÎßå, ÏùºÎ∂Ä Ïì∞Í∏∞ÎèÑ Í∞ÄÎä•
ROMÏùò Ï¢ÖÎ•ò
MROM (Mask ROM)
Ï†úÌíà ÏÉùÏÇ∞ Ïãú Î©îÎ™®Î¶¨Ïóê ÎÇ¥Ïö©ÏùÑ Í∏∞Î°ùÌïòÎäî ÌòïÌÉú
ÏµúÏ¥à ÌîÑÎ°úÍ∑∏Îû® Ïù¥ÌõÑ ÏÇ≠Ï†úÎÇò Ïû¨ Í∏∞Î°ùÏù¥ Î∂àÍ∞ÄÎä•
PROM (Programmable ROM) or FPROM (Field Programmable ROM)
ÏÉùÏÇ∞ Ïãú Î©îÎ™®Î¶¨Í∞Ä ÎπÑÏñ¥ ÏûàÏùå
Ïù¥ÌõÑ ÏÇ¨Ïö©ÏûêÏóê ÏùòÌï¥ Îî± ÌïúÎ≤à ÌîÑÎ°úÍ∑∏Îû® Îê† Ïàò ÏûàÎäî Î©îÎ™®Î¶¨, Í∑∏ Îã§Ïùå Read-Only
EPROM (Erasable PROM) or UV EPROM (Ultraviolet EPROM)
ÌïòÎìúÏõ®Ïñ¥Ï†ÅÏúºÎ°ú Î©îÎ™®Î¶¨ ÏàòÎ™ÖÏù¥ Îã§Ìï† ÎïåÍπåÏßÄ Ïû¨Í∏∞Î°ù Í∞ÄÎä•
Í∏∞Î≥∏Ï†ÅÏúºÎ°ú Í∏∞Î°ùÌïú Îç∞Ïù¥ÌÑ∞Îäî ÏÇ¨ÎùºÏßÄÏßÄ ÏïäÏùå
Ïû•ÏπòÏóêÏÑú Î©îÎ™®Î¶¨Î•º Ï†úÍ±∞ÌïòÏó¨ Ultraviolet lightÎ•º Ïù¥Ïö©Ìï¥ ÏßÄÏö∞Í≥† Î°¨ÎùºÏù¥ÌÑ∞ Îì±Ïùò Ïû•ÏπòÎ•º Ïù¥Ïö©Ìï¥ Ïû¨ÌîÑÎ°úÍ∑∏Îû® Í∞ÄÎä•
Í∏∞Î°ùÎêú ÎÇ¥Ïö© Ï†ÑÏ≤¥Î•º ÌïúÎ≤àÏóê ÏßÄÏõÄ
EEPROM (Electrically Erasable PROM)
Ï†ÑÍ∏∞ Ïã†Ìò∏Î°ú Îç∞Ïù¥ÌÑ∞Î•º ÏßÄÏö∞Îäî PROM
Î∞îÏù¥Ìä∏ Îã®ÏúÑÎ°ú ÎÇ¥Ïö©ÏùÑ ÏßÄÏö∞Í≥† Í∏∞Î°ùÌï† Ïàò ÏûàÏùå
Î≥ÑÎèÑÏùò Ïû•Ïπò ÏóÜÏù¥ Ïû•Ï∞© ÏÉÅÌÉú Í∑∏ÎåÄÎ°ú ÏàòÏ†ïÏù¥ Í∞ÄÎä•ÌïòÏßÄÎßå Í∏∞Î°ù ÏÜçÎèÑÍ∞Ä ÎäêÎ¶º
Flash Memories
EEPROMÏóê Í∏∞Î∞òÌïú ÎπÑÌúòÎ∞úÏÑ± Î©îÎ™®Î¶¨
(Î™®Î∞îÏùº Îì± Ï†ÑÏûêÍ∏∞Í∏∞ÏóêÏÑú) Îπ†Î•¥Í≥† ÏïàÏ†ïÏ†ÅÏù∏ ÎπÑÌúòÎ∞úÏÑ± Ï†ÄÏû•Ïû•ÏπòÏùò Ïó≠Ìï†ÏùÑ ÏàòÌñâ
Block Îã®ÏúÑ(Î≥¥ÌÜµ 512 byte, like Sector)Î°ú Í∏∞Î°ùÌïòÍ∏∞ ÎïåÎ¨∏Ïóê ÏÜçÎèÑÍ∞Ä Îπ†Î¶Ñ
ÌäπÏßï
No in-place writes; Ïù¥ÎØ∏ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÎäî Í≥≥Ïóê ÎçÆÏñ¥Ïì∞ÏßÄ Î™ª Ìï®
Asymmetric read-write speed; writeÎ≥¥Îã§ readÍ∞Ä Ìõ®Ïî¨ Îπ†Î¶Ñ
WriteÎäî Îç∞Ïù¥ÌÑ∞ ÏòÆÍ≤®Ïì∞Í∏∞, ÏßÄÏö∞Í∏∞ Îì±ÏùÑ Ìè¨Ìï®
10ÎßåÎ≤à Ï†ïÎèÑ ÏßÄÏö∞Î©¥ ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏùå (Î≤ÑÎ¶¨Îäî ÏòÅÏó≠)
NAND flash / NOR flash; Î≥¥ÌÜµ NAND FLASHÎ•º Îçî ÎßéÏù¥ ÏîÄ
SSD (Solid State Dish); ÌïòÎìúÎîîÏä§ÌÅ¨Î≥¥Îã§ ÎπÑÏã∏Í≥† Í∞ÄÎ≥çÍ≥† Ï∂©Í≤©Ïóê Í∞ïÌï®
Solid State? ÌïòÎìúÎîîÏä§ÌÅ¨ÏôÄ Îã¨Î¶¨ ÎîîÏä§ÌÅ¨Îì§ÏùÑ ÏõÄÏßÅÏù¥Îäî Î∂ÄÎ∂ÑÏù¥ ÏóÜÏùå
„ÄÄÌïòÎìúÎîîÏä§ÌÅ¨ HDD„ÄÄ
Disk = Platters ÏõêÌåê + Spindle ÌöåÏ†ÑÏ∂ï
Platters ÏõêÌåê ÏúóÎ©¥, ÏïÑÎû´Î©¥ 2Í∞úÏùò SurfacesÎ°ú Îç∞Ïù¥ÌÑ∞Î•º Ï†ÄÏû•
Í∞Å SurfaceÎäî trackÏúºÎ°ú Î∂àÎ¶¨Îäî Concentric ringÏúºÎ°ú Íµ¨ÏÑ± (10,000Í∞ú ÎÇ¥Ïô∏)
SRAMÎ≥¥Îã§ 40,000Î∞∞, DRAMÎ≥¥Îã§ 2,500Î∞∞ ÎäêÎ¶º
ÎîîÏä§ÌÅ¨ ÎèôÏûë

„ÄÄSSDs : Solid State Disks„ÄÄ
(Íµ¨ÏÑ±) = Ìïú Í∞ú Ïù¥ÏÉÅÏùò ÌîåÎûòÏãú Î©îÎ™®Î¶¨ Ïπ© + ÎîîÏä§ÌÅ¨ Ïª®Ìä∏Î°§Îü¨ FTL (Flash Translation Layer)
Page Îã®ÏúÑÎ°ú Îç∞Ïù¥ÌÑ∞Î•º ÏùΩÍ≥† ÏîÄ, ÏßÄÏö∞Í∏∞Îäî Block Îã®ÏúÑÎ°úÎßå Í∞ÄÎä•

ÌïòÎÇòÏùò PageÎ•º ÏßÄÏö∞Î†§Î©¥, Í∞ôÏùÄ BlockÏùò ÎÇòÎ®∏ÏßÄ ÌéòÏù¥ÏßÄÎ•º Îπà BlockÏúºÎ°ú ÏòÆÍ≤®Ïïº Ìï®
HDDÏôÄ Îã¨Î¶¨ Mechanical MoveÍ∞Ä ÏóÜÏñ¥ Îπ†Î•¥Í≥†, Ï†ÑÎ†• ÏÜåÎ™®ÎèÑ Ï†ÅÍ≥†, Í≤¨Í≥†Ìï®
Ìïú BlockÎãπ 10ÎßåÎ≤à Ïù¥ÏÉÅ Ïì∞Í∏∞Î•º Î∞òÎ≥µÌïòÎ©¥ Wear OutÎêúÎã§Îäî Ï†êÍ≥º ÎπÑÏã∏Îã§Îäî Ï†êÏù¥ Îã®Ï†ê
NVRAM (Non Volatile RAM)
ÎπÑÌúòÎ∞úÏÑ± RAM : Ï†ÑÏõêÏùÑ Ï∞®Îã®Ìï¥ÎèÑ Îç∞Ïù¥ÌÑ∞Î•º Ïú†ÏßÄÌïòÎäî RAM
Ï†ïÌôïÌûàÎäî ÎπÑÌúòÎ∞úÏÑ± SRAM(Static RAM)
ÏßëÏ†ÅÎèÑÍ∞Ä ÎÇÆÍ≥† Ï†ÑÎ†•ÏÜåÎ™®Í∞Ä ÎßéÍ≥† Íµ¨Ï°∞Í∞Ä Î≥µÏû°Ìï¥ ÏÉÅÎåÄÏ†ÅÏúºÎ°ú Ïö©ÎüâÏù¥ ÏûëÏßÄÎßå Îß§Ïö∞ Îπ†Î¶Ñ
ÌïòÎìúÎîîÏä§ÌÅ¨ Í∞ôÏùÄ ÎåÄÏö©Îüâ Ï†ÄÏû•Ïû•ÏπòÎ°úÎäî Î∂ÄÏ†ÅÌï©
Î©îÏù∏Î≥¥ÎìúÏóê Ï£ºÎ°ú ÏÇ¨Ïö©, Í∏∞Î≥∏Ï†ÅÏù∏ Î∂ÄÌåÖÏ†ïÎ≥¥Î•º Ï†ÄÏû•ÌïòÎäî Ïö©ÎèÑ
ÏûëÎèô Î∞©Ïãù
Î≥ÑÎèÑÏùò Ïô∏Î∂Ä Î∞∞ÌÑ∞Î¶¨Î•º ÌÜµÌï¥ Ï†ÑÏõê Ï∞®Îã® ÏãúÏóêÎèÑ Îç∞Ïù¥ÌÑ∞Î•º Ïú†ÏßÄ
EEPROM Ïó∞ÎèôÏùÑ ÌÜµÌï¥ Ï†ÑÏõê Ï∞®Îã® Ïãú Ìï¥Îãπ ÎÇ¥Ïö©ÏùÑ EEPROMÏóê Ï†ÄÏû•ÌñàÎã§Í∞Ä Ï†ÑÏõê Í≥µÍ∏â Ïãú Ìï¥Îãπ ÎÇ¥Ïö©ÏùÑ ÏùΩÏñ¥Ïò§Îäî Î∞©Ïãù

---

##### Edge Computing
### Edgd Computing
- Iot ÎîîÎ∞îÏù¥Ïä§Í∞Ä ÎÑ§Ìä∏ÏõåÌÅ¨Ïó£ÏßÄÏóêÏÑú Îç∞Ïù¥ÌÑ∞Î•º Ïã†ÏÜçÌïòÍ≤å Ï≤òÎ¶¨ÌïòÍ≥† ÏûëÎèôÌï† Ïàò ÏûàÎèÑÎ°ù ÌïòÎäî Î∂ÑÏÇ∞Ìòï Ïª¥Ìì®ÌåÖ ÌîÑÎ†àÏûÑÏõåÌÅ¨
### Edge Computing ÌäπÏßï
- ÏõêÍ≤© ÏúÑÏπòÏóê ÏûàÎäî Ïû•ÏπòÍ∞Ä Ïû•Ïπò ÎòêÎäî Î°úÏª¨ ÏÑúÎ≤ÑÎ•º ÌÜµÌï¥ ÎÑ§Ìä∏ÏõåÌÅ¨ ‚Äúedge‚ÄùÏóêÏÑú Îç∞Ïù¥ÌÑ∞Î•º Ï≤òÎ¶¨
- Ï§ëÏïô Îç∞Ïù¥ÌÑ∞ ÏÑºÌÑ∞Ïóê Í∞ÄÏû• Ï§ëÏöîÌïú Îç∞Ïù¥ÌÑ∞Îßå Ï†ÑÏÜ°ÌïòÏó¨ Ï≤òÎ¶¨ÌïòÎØÄÎ°ú ÎåÄÍ∏∞ ÏãúÍ∞Ñ ÏµúÏÜåÌôî

---

##### InfluxDB
- Basic Flux Query
Î™®Îì† Flux ÏøºÎ¶¨Îäî Îã§ÏùåÏùò Îã®Í≥ÑÍ∞Ä ÌïÑÏöîÌïòÎã§
1. data source
2. time range
3. data filters
1. data source Ï†ïÏùò
form()
InfluxDB data sourceÎ•º Ï†ïÏùòÌïòÎäî Ìï®Ïàò
bucket ÌååÎùºÎØ∏ÌÑ∞ ÌïÑÏöî
2. time Î≤îÏúÑ Ï†ïÏùò
range(start, stop)
ÏãúÍ∞Ñ Ïó∞ÏÜçÏ†ÅÏù∏ Îç∞Ïù¥ÌÑ∞Î•º ÏøºÎ¶¨Ìï† Îïå, ÏãúÍ∞Ñ Î≤îÏúÑÎ•º Î∞òÎìúÏãú ÏßÄÏ†ïÌï¥Ïïº Ìï®
"Unbounded" ÏøºÎ¶¨Îäî resource-intensive ÌïòÍ∏∞ ÎïåÎ¨∏Ïóê, Ïù¥Ïóê ÎåÄÌïú Î∞©ÏïàÏúºÎ°ú  ÏãúÍ∞Ñ Î≤îÏúÑÎ•º ÏßÄÏ†ïÌïòÏßÄ ÏïäÏúºÎ©¥, Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú ÏøºÎ¶¨Î•º Ïã§ÌñâÌï† Ïàò ÏóÜÎã§.
pipe-forward operator " |> " Î•º Ïù¥Ïö©ÌïòÏó¨, data sourceÎ°úÎ∂ÄÌÑ∞ range()Î°ú dataÎ•º Ïó∞Í≤∞ÌïúÎã§. range Îäî start, stop ÌååÎùºÎØ∏ÌÑ∞Î•º Í∞ÄÏßÄÎ©∞, negative duration ÎòêÎäî, timestampsÎ•º Ïù¥Ïö©Ìïú absolute Í∞íÏúºÎ°ú ÌëúÌòÑÌïúÎã§.
3. data ÌïÑÌÑ∞ÎßÅ
filter([Predicate Function])
filterÎäî  Î™®Îì† recordÎ•º ÎèåÎ©¥ÏÑú, Predicate Function Ïóê recordÎ•º ÏûÖÎ†•ÌïòÏó¨ ÌèâÍ∞ÄÎ•º ÏßÑÌñâÌïúÎã§. Í≤∞Í≥º Í∞íÏù¥  "true" Ïù¥Î©¥ output dataÎ°ú, "false"Ïù¥Î©¥ Í±∏Îü¨ÎÇ∏Îã§.
‚Äª Predicate Function : Predicate expressionÏùÑ Ïù¥Ïö©ÌïòÏó¨ recordÎ•º ÌèâÍ∞ÄÌï† Ìï®ÏàòÎ•º ÏûëÏÑ±ÌïúÎã§.
4. return
yield()
yield Ìï®ÏàòÎäî Í∞Å scriptÏùò ÎßàÏßÄÎßâÏóê ÏúÑÏπòÌïòÎ©∞, FluxÍ∞Ä ÏûêÎèôÏ†ÅÏúºÎ°ú dataÎ•º Ï∂úÎ†•ÌïòÍ≥† Í∞ÄÏãúÌôîÌïòÎèÑÎ°ù ÌïúÎã§.

### Write data
## Line protocol

timestamp = 2024-01-01T09:00:00Z
Flux query language
from(bucket: ‚Äúdb‚Äù)
	|> range(start: -15m, stop: now())
	|> filter(fn: ( r ) => r[‚Äú_measurement‚Äù] == ‚Äúsensors‚Äù) : select * from measurement
// |> filter(fn: ( r ) => r[‚Äú_field‚Äù] == ‚Äúvalue‚Äù)
	|> filter(fn: ( r ) => r[‚Äúdevice‚Äù] == ‚Äúweatherstation‚Äù)
	// |> aggregateWindow(every: 1m, fn: max) : @ InfluxDB UI
|> aggregateWindow(every: 1m, fn: mean)
	|> yield(name: ‚Äúmean‚Äù) : result
=> SELECT mean(value) FROM sensors WHERE device = ‚Äúweatherstation‚Äù AND time () GROUP BY sensor
InfluxDB: Flux Basics
from(bucket: ‚Äútelemetry‚Äù)
	|> range(start: -15m)
	|> filter(fn: ¬Æ => r._measurement == ‚Äúrpm‚Äù)
	|> aggregateWindow(every: 1m, fn: max)
	|> to(bucket: ‚Äútelemetry-downsample‚Äù)


### InfluxDB: Downsampling
option task = {
            name: ‚ÄúSunlight hourly average‚Äù,
            every: 1h,
            offset: 0m,
}
// Data source
from(bucket: ‚Äúorigin-db‚Äù)
	|> range(start: -task.every)
	|> filter(fn: ( r ) => r[‚Äú_measurement‚Äù] == ‚Äúsensors‚Äù)
            |> filter(fn: ( r ) => r[‚Äúdevice‚Äù] == ‚Äúmiflora‚Äù)
            |> filter(fn: ( r ) => r[‚Äúsensor‚Äù] == ‚Äúsunlight‚Äù)
	|> filter(fn: ( r ) => r[‚Äú_field‚Äù] == ‚Äúvalue‚Äù)
	// Data transformation
	|> aggregateWindow(
                     every: task.every,
                     fn: mean,
                     createEmpty: false,
             )
	|> to(
                     bucket: ‚Äúaggregates‚Äù,
                     fieldFn: ( r ) => ({‚Äúmean‚Äù: r._value}),
	)
	|> yield(name: ‚Äúmean‚Äù)

### InfluxDB RP and CQ
alter retention policy "autogen" on "graphite" duration 24h shard duration 1h default
CREATE RETENTION POLICY "twoday" ON "graphite" DURATION 2d REPLICATION 1
CREATE RETENTION POLICY "week" ON "graphite" DURATION 7d REPLICATION 1
CREATE RETENTION POLICY "month" ON "graphite" DURATION 31d REPLICATION 1
CREATE RETENTION POLICY "year" ON "graphite" DURATION 366d REPLICATION 1
CREATE RETENTION POLICY "inf" ON "graphite" DURATION INF REPLICATION 1
CREATE CONTINUOUS QUERY "cq_twoday" ON "graphite" BEGIN SELECT mean(value) as value INTO "graphite"."twoday".:MEASUREMENT FROM /.*/ GROUP BY time(60s),* END
CREATE CONTINUOUS QUERY "cq_week" ON "graphite" BEGIN SELECT mean(value) as value INTO "graphite"."week".:MEASUREMENT FROM /.*/ GROUP BY time(300s),* END
CREATE CONTINUOUS QUERY "cq_month" ON "graphite" BEGIN SELECT mean(value) as value INTO "graphite"."month".:MEASUREMENT FROM /.*/ GROUP BY time(1800s),* END
CREATE CONTINUOUS QUERY "cq_year" ON "graphite" BEGIN SELECT mean(value) as value INTO "graphite"."year".:MEASUREMENT FROM /.*/ GROUP BY time(21600s),* END
CREATE CONTINUOUS QUERY "cq_inf" ON "graphite" BEGIN SELECT mean(value) as value INTO "graphite"."inf".:MEASUREMENT FROM /.*/ GROUP BY time(43200s),* END

---

##### Python
### Generator(Ï†úÎÑàÎ†àÏù¥ÌÑ∞, ÏÉùÏÑ±Ïûê)
- Î©îÎ™®Î¶¨Î•º Ìö®Ïú®Ï†ÅÏúºÎ°ú ÏÇ¨Ïö©ÌïòÎäî Iterator(Ïù¥ÌÑ∞Î†àÏù¥ÌÑ∞, Î∞òÎ≥µÏûê)
yield : Ï†úÎÑàÎ†àÏù¥ÌÑ∞ ÏÉùÏÑ± ÌÇ§ÏõåÎìú
- Ï†úÎÑàÎ†àÏù¥ÌÑ∞ : Ïó¨Îü¨ Í∞úÏùò Îç∞Ïù¥ÌÑ∞Î•º ÎØ∏Î¶¨ ÎßåÎì§Ïñ¥ ÎÜìÏßÄ ÏïäÍ≥† ÌïÑÏöîÌï† Îïå ÌïòÎÇòÏî© ÏÉùÏÑ±ÌïòÎäî Í∞ùÏ≤¥ (Í≤åÏúºÎ•∏ Î∞òÎ≥µÏûêiterator)
- Í≤∞Í≥ºÍ∞íÏùÑ ÎÇòÎàÑÏñ¥ ÏñªÍ∏∞ ÎïåÎ¨∏Ïóê ÏÑ±Îä• Ï∏°Î©¥ÏóêÏÑú Ïù¥Ï†ê
- Í≤∞Í≥ºÍ∞íÏùÑ ÌïòÎÇòÏî© Î©îÎ™®Î¶¨Ïóê Ïò¨Î†§ÎÜìÍ∏∞ ÎïåÎ¨∏Ïóê Î©îÎ™®Î¶¨ Ìö®Ïú® Ï∏°Î©¥ÏóêÏÑúÎèÑ Ïù¥Ï†ê
- yield from list() : Î¶¨Ïä§Ìä∏Î•º Î∞îÎ°ú Ï†úÎÑàÎ†àÏù¥ÌÑ∞Î°ú Î≥ÄÌôò
- Ï†úÎÑàÎ†àÏù¥ÌÑ∞ ÌëúÌòÑÏãù : abc = (char for char in "ABC") -> Î¶¨Ïä§Ìä∏ ÌëúÌòÑÏãùÍ≥º Îã§Î•¥Í≤å ÏÜåÍ¥ÑÌò∏Î°ú ÌëúÌòÑ

### Win32com


'''Python
# Import our libraries
import win32com.client as win32
import pythoncom

# Define our Application Events
class ApplicationEvents:
    # Define an event inside of our application
    def OnSheetActivate(self, *args):
        print("Activated new sheet")

# Define our Workbook Events
class WorkbookEvents:
    # Define an event inside of our Workbook
    def OnSheetSelectionActivate(self, *args):
        # Print the arguments
        print(args)
        print(args[1].Address)
        args[0].Range("A1").Value = f"You selected cell {args[1].Address}"
        print("Activated new sheet")

# Get the active instance of Excel
xl = win32.GetActiveObject("Excel.Application")
# Assign our event to the Excel Application Object
xl_events = win32.WithEvents(xl, ApplicationEvents)

# Grab the workbook
xl_workbook = xl.Workbooks("Book1")
# Assign events to workbook
xl_workbook_events = win32.WithEvents(xl_workbook, WorkbookEvents)
# While there are messages keep displaying them
while True:
    # Display the message
    pythoncom.PumpWaitingMessages()
'''

---

##### subprocessing
- Python pkg
ÌòÑÏû¨ ÏÜåÏä§ÏΩîÎìú ÏïàÏóêÏÑú Îã§Î•∏ ÌîÑÎ°úÏÑ∏Ïä§Î•º Ïã§ÌñâÌï¥Ï£ºÎ©∞ Í∑∏ Í≥ºÏ†ïÏóêÏÑú Îç∞Ïù¥ÌÑ∞Ïùò ÏûÖÏ∂úÎ†•ÏùÑ Ï†úÏñ¥ÌïòÍ∏∞ ÏúÑÌï¥ ÏÇ¨Ïö©
Í∏∞Ï°¥ system, os pkgÎ•º ÏÇ¨Ïö©ÌïòÎçò Í∏∞Îä•ÏùÑ python3Î∂ÄÌÑ∞ Î≥¥ÏïàÏÉÅÏùò Ïù¥Ïú†Î°ú subprocessÎ°ú Ïù¥Í¥Ä
‚Üí subprocess Î™®ÎìàÏùÄ ÏÉàÎ°úÏö¥ ÌîÑÎ°úÏÑ∏Ïä§Î•º Ïã§ÌñâÌïòÎèÑÎ°ù ÎèÑÏôÄÏ£ºÍ≥† ÌîÑÎ°úÏÑ∏Ïä§Ïùò ÏûÖÏ∂úÎ†• Î∞è ÏóêÎü¨ Îì± Î¶¨ÌÑ¥ ÏΩîÎìúÎ•º Ïú†Ï†ÄÍ∞Ä ÏßÅÏ†ë Ï†úÏñ¥ÌïòÍ≤å Ìï¥Ï£ºÎäî Î™®ÎìàÏù¥Îã§.
Python3.5Î∂ÄÌÑ∞ subprocess.run() Î©îÏÜåÎìúÎ•º ÌÜµÌï¥ subprocessÎ•º Ïã§Ìñâ
Ïâò Î™ÖÎ†πÏñ¥ Ïã§Ìñâ
Import subprocess

# Linux : 
subprocess.run([‚Äòls‚Äô], shell=True, check=True)
# Windows :
subprocess.run([‚Äòdir‚Äô], shell=True, check=True)

ÌååÏù¥Ïç¨ ÏÜåÏä§ÏΩîÎìú Ïã§Ìñâ
Import subprocess

subprocess.run([‚Äòtest.py‚Äô], shell=True)

subprocess.check_output() Î©îÏÜåÎìúÎ•º ÏÇ¨Ïö©Ìï¥ Ïª§Îß®Îìú Ïã§Ìñâ Í≤∞Í≥ºÎ•º Î©îÎ™®Î¶¨ÏÉÅ Ï†ÄÏû•ÌïòÍ≥† Î∞òÌôò
Ïã§Ìñâ Í≤∞Í≥º Î∞òÌôò
Import subprocess

Result = subprocess.check_output([‚Äòtest.py‚Äô], shell=True, encoding=‚Äôutf-8‚Äô)

# run Î©îÏÜåÎìúÏùò Ïù∏Ïàò
Import sys
Result = subprocess.run(args=[sys.executable, ‚Äòtest.py‚Äô], capture_output=True)

Popen
Ïú†Ïó∞Ìïú ÏÑúÎ∏åÌîÑÎ°úÏÑ∏Ïä§Î•º Ïã§ÌñâÌïòÍ≥† Í≤∞Í≥ºÎ•º Î∞òÌôò
